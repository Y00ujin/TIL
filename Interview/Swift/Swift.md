## Swift, OS 면접질문 정리

<br>
<br>
<br>

- ### hugging, resistance에 대해서 설명하시오.
##### 두 오브젝트를 배치할 때 공간이 남을 경우 무엇이 커질 지 설정해주는 것이 hugging priority 입니다. A오브젝트를 250으로 설정하고 B오브젝트를 251로 설정할시 우선순위가 더 낮은 A오브젝트가 남은 공간을 채우기 위해 그만큼 커집니다. resistance는 공간이 부족할 때 무엇이 줄어들지 설정해주는 것이 compression resistance priority입니다. A오브젝트를 750으로 설정하고 B오브젝트를 749로 설정하면 B오브젝트가 줄어들게 됩니다.
<br>
<br>


- ### Intrinsic Size에 대해서 설명하시오.
##### Intrinsic Size는 컨텐츠의 본질적인 크기를 가르킵니다. UILabel, UIButton, UISwitch, UITextField등이 Intrinsic Content Size Width, Height를 가지며 UIView는 Intrinsic Content Size를 가지지 않습니다.
<br>
<br>

- ### Left Constraint 와 Leading Constraint 의 차이점을 설명하시오.
##### leading은 텍스트의 시작점을 나타냅니다. trailing은 텍스트의 끝을 나타내며 left는 단순히 왼쪽, right는 오른쪽을 나타냅니다. RTL과 LTR 모두 원활히 지원하기 위해선 leading, tailing을 사용해야합니다.
<br>
<br>


- ### Safearea에 대해서 설명하시오.
##### iOS 11에서 UIViewController의 topLayoutGuide와 bottomLayoutGuide는 UIView의 safe area 속성으로 변경되었습니다. 아이폰 X부터 상단의 노치와 하단의 홈바에는 콘텐츠가 제대로 표시될 수 없기 때문에, 이 부분을 제외한 콘텐츠가 안전하게 표시될 수 있는 영역을 의미합니다.
<br>
<br>

- #### 프로세스란 무엇인가?
##### 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 됩니다. 이 순간부터 프로세스라 불립니다. 이 프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이기도 합니다. 프로세스는 각각의 독립된 메모리 영역을 각자 할당받습니다.
<br>
<br>

- #### 스레드란 무엇인가?
##### 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름의 단위으로 각 스레드들은 별도의 Stack을 가지고있으며 Code, Data, Heap은 프로세스 내의 다른 스레드들과 공유합니다. 
<br>
<br>


- ### 멀티 프로세스는 무엇인가요?
##### 두개 이상 다수의 프로세서(CPU)가 협력적으로 하나 이상의 작업을 병렬처리하는 것 입니다. 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용합니다. 각 프로세스는 독립된 구조이기 때문에 안정성이 높습니다. 하지만 Context Switching 시 CPU의 부담도 커지고 오버헤드가 발생하게 된다는 것이 가장 큰 단점입니다. 또 프로세스 간 자원 공유가 어렵습니다.
<br>
<br>

- ### Context Switching이 무엇인가요?
##### CPU에 실행할 프로세스를 교체하는 기술입니다. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서 메인 메모리 저장합니다. 다음 실행할 프로세스 정보를 메인 메모리에 있는 

- ### 멀티 스레딩은 무엇인가요?
##### 두개 이상의 쓰레드가 하나의 프로그램을 구성하여 각 쓰레드마다 하나의 작업씩 처리하도록 하는 것 입니다. 멀티 스레딩은 쓰레드 간 Code, Data, Heap 영역을 공유하기 때문에, Context Switching이 빠르며 프로세스를 생성하여 자원을 할당하는 것이 아니기 때문에, 생성 종료 시간도 프로세스보다 빠릅니다. 또 프로세스 간 통신이 까다로운 반면에, 쓰레드들은 stack영역을 제외한 나머지 영역을 공유하기 때문에 통신 방법이 훨씬 간단합니다. 하지만 자원을 공유하기때문에 A쓰레드가 접근하려는 힙 영역의 자원을 B가 접근해서 바꾸는 등 자원 공유의 문제가 생길 수 있으며, 독립적이지 않아 하나의 쓰레드에서 문제가 발생 시 전체 쓰레드가 영향을 받습니다. 
<br>
<br>


- ### 멀티 프로세스와 멀티 스레딩의 차이는 무엇인가요?
##### 멀티 프로세스는 메모리를 모두 독립적으로 할당하는 반면 멀티 쓰레드는 Code, Data, Heap만 공유하고 Stack만 독립적으로 할당합니다. 위와 같은 특징에 따라 멀티 프로세스는 ContextSwitching시 시간이 많이 소요되며, 멀티 쓰레드는 Context Switching이 빠릅니다. 멀티 프로세스는 독립적이기 때문에 IPC를 통해 자원에 접근해야하지만 멀티 쓰레드는 Code, Data, Heap을 공유하기 때문에 프로세스 간 자원 공유가 비교적 간단합니다. 또 멀티 프로세스는 독립된 구조이기 때문에 안전성이 높지만, 멀티 쓰레드는 하나의 쓰레드에서 문제 발생 시 전체 쓰레드에 영향이 갑니다.
<br>
<br>

- ### 멀티 쓰레드로 동작하는 앱을 작성하고 싶을 때 고려할 수 있는 방식들을 설명하시오.
##### 
<br>
<br>

- ### Mutable, Immutable에 대해 설명하시오.
#####
<br>
<br>

- ### Protocol에서는 왜 var만 되는지 설명하시요.
#####
<br>
<br>

- ### struct와 class와 enum의 차이를 설명하시오.
##### struct는 상속이 불가능하며 stack영역에 저장됩니다. 또한 속도가 빠르며 멀티 쓰레드 환경에서 안전하고 값 타입입니다. class는 단일 상속이 가능하며, 실제 데이터는 Heap에 저장되고 실제 데이터가 위치한 Heap 메모리 주소가 Stack에 저장되며 상대적으로 느립니다. 클래스는 참조타입이며, enum은 상속이 불가능하고 값 타입입니다.
<br>
<br>

- ### let 키워드에 대해 설명하시오.
##### let으로 선언된 인스턴스는, 인스턴스에서 할당된 stack 영역의 메모리 공간을 변경하지 못하게 합니다. 따라서 Stack 영역에 실제 데이터가 저장되는 값 타입 인스턴스들을 속성을 수정하지 못합니다. 하지만 Stack영역에 Heap영역의 메모리 주소가 저장되는 참조 타입 인스턴스들은 가리키는 대상만 수정하지 못할 뿐 속성을 수정할 수 있습니다.
<br>
<br>

- ### 메모리 구조와 각 역할에 대해 설명하시오.
##### 메모리는 코드, 데이터, 힙, 스택으로 이루어져 있습니다. 코드영역에는 우리가 작성한 소스코드가 binary 형태로 저장되며, Read-Only로 저장됩니다. 데이터 영역에는 전역변수, static 변수가 저장되며, 프로그램 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리가 해제됩니다. 실행 도중 값이 변경될 수 있으므로 Read-Write로 저장됩니다. 힙 영역에는 참조 타입의 값이 저장되며 Swift는 ARC를 통해 힙에 할당된 메모리가 더 이상 참조되지 않으면 자동으로 메모리를 해제해줍니다. 스택에는 함수의 호출과 관계되는 지역변수와 매개변수가 저장됩니다. 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸합니다. 스택은 LIFO 방식으로 작동하며 CPU에 의해 관리되고 최적화 돼서 속도가 매우 빠릅니다.
<br>
<br>


- ### Copy On Write는 어떤 방식으로 동작하는지 설명하시오.
##### 프로그래밍에서 복사 동작을 할 때, 실제 원본이나 복사본이 수정되기 전까지는 복사를 하지 않고 원본 리소스를 공유하다가 원본이나 복사본에서 수정이 일어날 경우, 그때 복사를 진행하는 방식으로 동작합니다.
<br>
<br>

- ### Convinience init에 대해 설명하시오.
##### Designated init의 파라미터 중 일부를 기본값으로 설정해서, 이 convenience init안에서 Designated init을 호출하여 초기화를 진행할 수 있습니다. convenience init을 사용하기 위해서는 designated init이 반드시 먼저 선언되어야 합니다.
<br>
<br>

- ### Any에 대해 설명하시오.
##### Any는 모든 타입의 인스턴스를 나타낼 수 있는 범용 타입입니다. value 타입, Reference타입이건 상관없이 저장이 가능합니다.
<br>
<br>

- ### AnyObject에 대해 설명하시오.
##### AnyObject는 클래스 타입의 인스턴스를 나타낼 수 있는 프로토콜입니다. 따라서 클래스 타입이 아닌 구조체, 열거형, 클로저는 AnyObject에 해당하지 않습니다.
<br>
<br>

- ### Optional 이란 무엇인지 설명하시오.
##### 변수의 값이 있을 수도있고 nil일 수 있다는 것을 표현하는 것 입니다. Optional 변수의 선언은 ?키워드를 사용하며 디폴트 값은 nil입니다.
<br>
<br>

- ### Struct 가 무엇이고 어떻게 사용하는지 설명하시오.
##### 구조체란 인스턴스 프로퍼티를 저장하거나 메소드를 제공하고 이를 캡슐화할 수 있는 타입(named type)입니다. struct키워드로 정의하며 대문자 카멜케이스를 사용합니다. 구조체 정의 후 기본적으로 생성되는 멤버와이즈 이니셜라이저를 사용하여 초기화할 수 있으며 프로퍼티 값에 접근하고 싶다면 마침표를 사용하면 됩니다.
<br>
<br>

- ### Subscripts에 대해 설명하시오.
##### 콜렉션, 리스트, 시퀀스 등 집합의 특정 member elements에 접근할 수 있는 문법입니다. 서브스크립트는 subscript키워드로 작성하며 하나 이상의 파라미터와 반환 값을 지정하여 정의합니다. getter와 setter 모두 구현가능하며, get-only는 가능하지만, set-only는 불가능합니다.
<br>
<br>

- ### String은 왜 subscript로 접근이 안되는지 설명하시오.
##### String은 1개 이상의 Unicode Scalar로 이루어져있습니다. 그리고 유니코드 시스템에선 글자 하나가 반드시 1바이트라는 보장이 없습니다. 하나의 이모티콘은 여러개의 unicodeScalars로 이루어져 있는 것을 확인할 수 있습니다. 또 String은 하나의 값에 다양한 뷰를 제공하기 때문에, 단순히 Int타입으로 글자들을 참조하기에는 어떠한 뷰를 기준으로 인덱싱을 지원해야하는 지에 대해 애매한 부분이 존재합니다. 이 때문에 String은 별도로 설계된 String.Index라는 구조체를 제공하여 인덱싱을 지원합니다.
<br>
<br>

- ### 함수와 메서드의 차이를 설명하시오.
##### func 키워드로 생성하는 재사용 가능한 코드 블록을 함수라고 하며 func으로 선언한 함수가 클래스, 구조체, 열거형 속에 포함되어 있다면 메서드라고 표현합니다.
<br>
<br>

- ### instance 메서드와 class 메서드의 차이점을 설명하시오.
##### 먼저 intstance 메서드는 인스턴스 메서드이기 때문에 인스턴스와 연관된 메서드로 인스턴스를 생성해야만 호출이 가능합니다. 하지만 class 메서드는 타입 메서드이기 때문에 인스턴스를 생성하지 않아도 타입으로 접근할 수 있습니다.
<br>
<br>

- ### class 메서드와 static 메서드의 차이점을 설명하시오.
##### class 메서드와 static 모두 Type 메서드이지만 메서드 오버라이딩에 있어서 차이가 있습니다. static 메서드는 Subclass에서 해당 타입의 메서드를 오버라이딩 하는 것을 금지합니다. class는 static과 반대로 Subclass에서 해당 타입 메서드를 오버라이딩 하는 것을 허용합니다.
<br>
<br>

- ### Delegate 패턴을 활용하는 경우를 예를 들어 설명하시오.
##### ViewController를 보면, TableView의 특정 셀에 있는 여러 개의 버튼 중 특정 버튼을 눌렀을 경우에 해야할 일을 ViewController로 넘겨주기 위해 Delegate 패턴을 사용합니다. TableViewCell이 선택되었을 경우 호출하는 기능은 TableView Delegate에서 기본적으로 처리하고있지만, 셀 내부의 특정 버튼에 대한 이벤트는 처리할 수 없습니다. 이와 같은 경우엔 Custom Delegate를 만들어 구현이 가능합니다.
<br>
<br>

- ### Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.
##### 싱글톤 패턴은 객체를 하나 생성해서 공용으로 사용하고 싶을 때 사용하는 방법입니다. 즉. 인스턴스가 하나만 존재하는 것을 보증하고 싶을 경우에 사용하게 되는데, 주로 환경설정, 네트워크 객체, 로그인 정보 등을 넣어두고 필요할 때마다 여러 객체에서 접근 가능하도록 합니다.
<br>
<br>

- ### KVO 동작 방식에 대해 설명하시오.
##### KVO는 객체의 어떤 값이 변경되었을 경우 특정 메시지를 보내 처리할 수 있도록 하는 것입니다. 즉, 변수에 코드를 붙여 변수가 변경될 때마다 특정 코드가 실행되도록 하는 방법을 의미합니다. property observers(willset, didSet)고 아주 유사한데 KVO는 타입 정의 밖에서 observe를 추가한다는 점에서 다릅니다. KVO를 구현하려면 먼저 감지하려는 객체에 옵저버를 등록하고 해당 객체에 @objc, dynamic 키워드를 붙여 객체의 변화가 일어났을 때 옵저버의 메시지를 받아 처리하면 됩니다. Objective-C 런타임에 의존하기 때문에 NSObject를 채택해야합니다.
<br>
<br>

- ### Delegates와 Notification 방식의 차이점에 대해 설명하시오.
##### 먼저 두 방식 모두 객체간의 소통을 위해 만들어진 것인데, 먼저 delegate는 protocol을 정의하고 이 이벤트를 대신 처리할 객체가 채택하여 사용하게 되기때문에 주로 1:1로 이벤트를 전달할 때 많이 사용됩니다. notification 방식은 이벤트를 1:N으로 전달할 때 용이합니다. NotificationCenter라는 싱글톤객체를 기반으로 이벤트 발생여부를 옵저버를 등록한 객체에게 전달하는 방식으로 구성됩니다. 따라서 다수의 객체에게 손쉽게 이벤트 전달이 가능합니다.
<br>
<br>

- ### 프로토콜이란 무엇인지 설명하시오.
##### protocol은 특정 작업또는 기능을 구현하기 위한 메소드, 프로퍼티 그리고 기타 다른 요구사항들의 청사진입니다. 즉 protocol은 정의만 제시하고 세부적인 구현은 해당 protocol을 채택한 Type에서 구현합니다.
<br>
<br>

- ### Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.
##### Hashable은 정수 hash값을 제공하는 타입으로 정의된 프로토콜입니다. 해시값은 인스턴스를 식별하는 값으로 유일성을 가지고 있어야 합니다. 해시 값이 유일한 값인지를 비교해야하기 때문에 Equatable 프로토콜을 상속 받아 값을 비교할 수 있도록 하고있습니다.
<br>
<br>

- ### mutating 키워드에 대해 설명하시오.
##### Swift에서 구조체와 열거형과 같은 값 타입의 속성은 기본적으로 인스턴스 메서드 내에서 수정할 수 없습니다. 값 타입의 속성을 수정하려면 인스턴스 내에서 mutating키워드를 사용해야합니다. func 키워드 앞에 mutating 키워드를 작성하면 값 타입 프로퍼티를 수정할 수 있습니다.
<br>
<br>

- ### 탈출 클로저에 대하여 설명하시오.
##### Swift에서는 함수의 파라미터로 전달된 클로저는 기본적으로 함수 내부에서만 사용이 가능합니다. 즉 파라미터로 전달받은 클로저는 내부에서 직접 호출만 가능하고, 외부 변수/상수에 저장하는 것이 불가능한 형태입니다. 이때 클로저 앞에 @escaping 키워드를 사용하면 해당 클로저를 외부 변수/상수에 저장이 가능하며, 해당 함수가 끝나서 리턴된 이후에도 클로저 실행이 가능합니다.
<br>
<br>

- ### Extension에 대해 설명하시오.
##### Extension이란 기존 클래스, 구조체, 열거형 타입에 새로운 Property, Method, Initializer 등을 추가하는 것입니다. 저장 프로퍼티는 추가할 수 없으며, 연산 프로퍼티만 추가 가능합니다. 메서드는 인스턴스 메서드, 타입 메서드 모두 추가 가능합니다. Class에서는 Designated Initializer와 deinitializer는 추가할 수 없으며, Convenience initializer만 추가할 수 있습니다. Struct에서 extension으로 생성자를 추가할 시에는 Memberwise Initializer를 보존하며 새로운 Initializer를 추가할 수 있습니다. 또한 Where을 사용하여 특정 조건을 만족시킬 때만 기능을 확장시킬 수 있습니다.
<br>
<br>

- ### Extension 내부에서 함수를 override할 수 있는지 설명하시오.
##### 기본적으로 불가능하며 메소드가 Objective-C와 호환되는 경우에만 메소드를 Override할 수 있습니다. 즉, @objc 키워드를 func 앞에 작성해주면 Extension에서 해당 함수를 override할 수 있습니다. 이러한 동작이 가능한 이유는 컴파일러가 Objective-C와의 호환성을 위해 Extension에서 Override를 허용하기 때문입니다.
<br>
<br>

- ### 접근 제어자의 종류엔 어떤게 있는지 설명하시오.
##### 접근제어자로는 open, public, internal, fileprivate, private이 있습니다. 먼저 private은 가장 한정적인 범위로 기능을 정의하고 구현한 범위 내에서만 사용이 가능합니다. Fileprivate는 Fileprivate으로 지정된 요소가 구현된 소스파일 내부에서만 사용이 가능합니다. Internal은 직접 표기하지 않아도 기본적으로 적용되는 접근 수준으로 해당 모듈 전체에서 사용 가능합니다. public과 Open 모두 선언한 모듈이 아닌 다른 모듈에서도 사용가능합니다. 
<br>
<br>

- ### open과 public 키워드의 차이를 설명해보세요.
##### Open은 다른 모듈에서 오버라이드와 서브클래싱이 가능하지만 Public 접근자로 선언된 것은 다른 모듈에서는 오버라이드와 서브클래싱이 불가능합니다.
<br>
<br>

- ### fileprivate을 설명하고 언제 사용하면 좋을지 이야기해보세요.
##### fileprivate은 같은 소스파일 내에서의 접근만 허용합니다. 따라서 같은 파일 내부에서만 사용될 때 filprivate으로 제한하면 좋습니다.
<br>
<br>

- ### fileprivate과 private의 차이를 설명해보세요.
##### fileprivate은 같은 파일 내부에 있다면 접근을 허용했지만, private은 같은 파일에 있어도 private으로 선언한 대상의 구현부 내부, 그리고 같은 파일에 있는 동일한 선언의 Extension에서만 접근이 가능합니다.
<br>
<br>


- ### defer란 무엇인지 설명하시오.
##### defer문이 속한 함수 종료 직전에 실행되는 구문입니다. 다중 defer문이 존재한다면 역순으로 실행됩니다. 하지만 defer문을 만나기 전에 종료된다면 스택에 저장될 수 없으므로 스코프 종료 후에도 defer 문이 실행되지 않습니다.
<br>
<br>

- ### defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.
##### defer는 순차적으로 스택에 저장하기 때문에 LIFO로 호출됩니다. 즉 선언된 역순으로 호출되며 선언된 코드 블럭을 빠져나가기 직전에 실행됩니다. defer가 호출되기 전에 함수가 종료될 때 defer가 불리지 않습니다. defer가 호출되지 않는 경우는 throw를 이용하여 오류를 던질 경우입니다. defer 구문에 도달하기 전에 함수가 종료되어 버리면 스택에 저장 될 수 없기 때문에 defer가 호출되지 않습니다. guard문을 사용하여 중간에 함수를 종료하는 경우에도 동일한 이유로 호출되지 않습니다. 또한 리턴값이 Never인 경우에도 호출되지 않습니다.
<br>
<br>

- ### Generic에 대해 설명하시오.
##### 제네릭이란 타입에 의존하지 않는 범용 코드를 작성할 때 사용합니다. 제네릭을 사용하면 중복을 피하고, 코드를 유연하게 작성할 수 있습니다. 제네릭 함수를 통해 함수를 호출할 때 Type Parameter의 타입을 결정하여 타입에 상관없이 함수를 사용할 수 있습니다. 또한 구조체, 클래스, 열거형에도 제네릭을 결합할 수 있으며, 제네릭 타입이라고 합니다.
<br>
<br>

- ### Result타입에 대해 설명하시오.
##### Result타입은 success와 failure 두 가지 case가 있는 enum입니다. 그중 Failure은 Error Protocol을 준수해야합니다. 기존의 throwing function은 정확히 어떤 에러 형식을 던지는지 파악하기 어려운 반면 Result Type을 활용하면 작업의 결과를 명확히 구분 가능합니다. 네트워크와 같이 실패할 가능성이 있는 작업의 성공여부와 결과를 쉽게 표현할 수 있습니다.
<br>
<br>

- ### Typealias에 대해 설명하시오.
##### Typealias는 기존에 선언되어있는 유형에 새로운 유형의 별칭을 사용함으로써 코드를 더 쉽게 이해할 수 있게 하는 문법입니다. Swift에서는 typealias를 대부분의 유형에 사용할 수 있으며, 크게 내장 유형, 사용자 정의 유형, 복합 유형이 있습니다.
<br>
<br>

- ### Codable에 대하여 설명하시오.
##### Codable이라는 Typealias는 Decodable과 Encodable 프로토콜을 준수하는 타입입니다.
<br>
<br>


- ### enum / function / closure 각각 value type 인가 reference type 인가?
##### enum은 값 타입이며 function과 closure는 참조타입입니다.
<br>
<br>

- ### Array, Dictionary, Set 등의 컬렉션 타입은 value type 인가 reference type 인가?
##### Struct로 구현되어있으므로 값 타입입니다.
<br>
<br>

- ### Set에 대하여 설명하시오.
##### set은 정렬되지 않은 컬렉션입니다. 배열과 달리 중복 요소를 허용하지 않으며, 해시를 통해 값을 저장하기 때문에 배열에 비해 검색 속도가 빠르고, 저장되는 자료형은 Hashable 프로토콜을 준수하고 있어야 합니다. 또한 Set도 배열, 딕셔너리와 같은 Collection Type이기 때문에, 구조체로 Stack에 저장됩니다.
<br>
<br>

- ### Swift의 upcasting과 downcasting의 차이에 대해서 설명해보세요.
##### upcasting은 상속 관계가 있는 클래스들끼리만 가능합니다. as를 사용하여 업 캐스팅 할 수 있으며 컴파일 타임에 타입 캐스팅하여 항상 성공합니다. downcasting은 슈퍼 클래스 인스턴스를 서브 클래스 타입으로 참조합니다. 다운 캐스팅은 실패할 수 있기 때문에 as?, as! 연산자를 사용합니다.
<br>
<br>

- ### as? 와 as! 차이를 설명해보세요.
##### as?는 실패할 경우 nil을 리턴합니다. as!는 실패할 경우 에러가 발생합니다.
<br>
<br>

- ### == 연산자와 === 연산자는 어떻게 다른가요? 
##### == 연산자는 값을 비교하는데 사용되고, === 연산자는 참조 값을 비교하는데 사용됩니다.
<br>
<br>

- ### Enum에서 raw value와 associated value에 대해 설명해보세요
##### raw value 원시값은 모든 케이스가 동일한 형식을 사용해야하고, 케이스당 값을 하나밖에 저장할 수 없는 한계점이 있는데, 연관 값은 튜플을 사용하여 하나의 케이스에 서로 다른 연관값들을 저장할 수 있습니다. named tuple을 사용하여 이름을 붙일 수도 있으며, 다양한 타입을 가진 여러개의 값들을 가지게 할 수 있습니다.
<br>
<br>

- ### inout은 언제 사용하면 좋을까요?
##### swift에서 파라미터는 기본적으로 상수입니다. 이러한 파라미터를 수정하고 싶을 때 파라미터의 형식 앞에 inout키워드를 작성한 후 함수를 호출할 때 인자값으로 넘어가는 변수명 왼쪽에 & 기호를 붙여 사용합니다. 이러한 역할을 수행하는 inout 키워드는 매개변수로 넘겨진 변수의 값을 함수 내에서 변경시키고 함수가 반환된 후에도 이 변환된 값을 원본 변수에 적용시키고 싶을 때 사용합니다.
<br>
<br>

- ### 메서드 안에서 언제 self를 사용해야할까요?
##### 파라미터의 이름이 인스턴스 프로퍼티 이름과 겹칠 경우, 인스턴스의 프로퍼티임을 명시하기 위해서 self를 사용할 수 있습니다.
<br>
<br>

- ### Class와 Struct의 공통점과 차이점을 설명해보세요.
##### Class와 Struct 모두 값을 저장할 프로퍼티를 선언할 수 있으며, 메서드를 선언할 수 있습니다. 내부 값에 .을 사용하여 접근할 수 있고, 생성자를 사용해 초기 상태를 설정할 수 있습니다. Extension을 사용하여 기능을 확장할 수 있으며, protocol을 채택하여 기능을 설정할 수 있습니다. 하지만 Class는 참조타입이며, ARC로 메모리를 관리합니다. 또한 상속이 가능하며 타입 캐스팅을 통해 런타임에서 클래스 인스턴스 타입을 확인할 수 있습니다. 반면에 Struct는 값 타입이며, 상속이 불가능합니다.
<br>
<br>

- ### 강한 참조는 무엇이고 왜 필요한가요?
##### 강한 참조는 참조 타입 인스턴스를 변수에 할당하는 것을 의미합니다. 스위프트의 ARC는 강한 참조에 참조 카운트를 증가시킵니다. 따라서 강한 참조가 있어야만 스위프트에서 참조 타입의 인스턴스를 메모리에 유지할 수 있습니다.
<br>
<br>

- ### strong, weak, unowned reference는 각각 언제 사용할까요?
##### 메모리에서 인스턴스가 해제되는 것을 막기 위해 Strong reference를 사용할 수 있습니다. strong reference는 참조 카운트를 1 증가시키기 때문에 메모리에서 해제되지 않습니다. weak reference는 참조 카운트를 증가시키지 않습니다. weak reference는 항상 var로 선언되는 옵셔널 타입이 되어야 합니다. weak으로 참조하고 있던 인스턴스가 해제될 수 있기 때문입니다. 순환 참조의 가능성이 있는 상황에서 weak을 통해 방지할 수 있습니다. unowned reference는 weak과 동일하게 참조 카운트를 증가시키지 않습니다. 그리고 unowned로 선언된 변수는 nil을 가질 수 없습니다. unowned로 참조하고 있던 인스턴스가 해제되면 unowned는 nil이 아니라 더 이상 참조할 수 없는 주소를 계속 참조하게 되고 unowned 변수를 참조하려고 하면 런타임 에러가 발생합니다. 따라서 unowned는 해당 변수가 참조하는 인스턴스보다 먼저 해제되는 것이 확실한 상황에서만 사용해야합니다.
<br>
<br>

- ### Array, Set, Dictionary의 차이점이 뭘까요?
##### Array는 리스트 컬렉션으로 인덱스를 통해 요소에 접근할 수 있습니다. Set은 Hashable 프로토콜을 채택하는 값을 저장해 중복되지 않은 데이터를 관리합니다. 순서가 보장되지 않으며, 교집합, 차집합 등 집합 연산을 메서드로 제공합니다. Dictionary는 Key-Value 형태로 데이터를 관리하는 콜렉션입니다. 딕셔너리의 Key로 사용될 타입은 Hashable 프로토콜을 채택하고 중복된 키를 허용하지 않으며 순서를 보장하지 않습니다.
<br>
<br>

- ### required 키워드에 대해서 설명해보세요.
##### required 키워드를 사용하여 이니셜라이저를 지정할 수 있습니다. 이 필수 이니셜라이저는 모든 자식 클래스에서 반드시 구현해야 하는 이니셜라이저로, required 키워드를 붙여 사용 가능하고 자식 클래스에서 구현할 때에도 required 키워드를 붙여야 합니다. required는 오버라이드를 기본으로 포함하고 있습니다.
<br>
<br>

- ### Self와 self의 차이가 뭘까요?
##### self는 현재 인스턴스를 가리킵니다. Self는 프로토콜에서 사용되면 프로토콜을 채택하는 타입을 의미하고, 클래스나 구조체, 열거형에서 사용되면 실제 선언에 사용된 타입을 의미합니다.
<br>
<br>

- ### Array보다 Set을 사용하는게 더 좋을 때는 언제일까요?
##### 순서가 중요하지 않고 데이터를 중복없이 고유하게 관리할 때 Set을 사용하는 것이 더 좋습니다. 특히 Set은 삭제, 삽입, 조회를 모두 O(1)에 할 수 있기 때문에 순서가 중요하지 않으면서 삭제와 삽입이 빈번할 때도 Set이 더 좋을 수 있습니다.
<br>
<br>

- ### Trailing Closure에 대해서 설명해보세요.
##### 함수의 마지막 인자가 클로저 표현식을 넘기는 경우라면, 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일 수 있는 문법을 의미합니다. 이 때 인자 레이블은 생략되며, 함수 호출 괄호 () 뒤에 중괄호를 사용하여 클로져를 작성합니다.
<br>
<br>

- ### deinit은 언제 사용할까요?
##### deinit은 인스턴스가 메모리에서 해제되기 직전에 호출됩니다. 인스턴스를 해제하기 전에 선행되어야 하는 작업이 있다면 deinit에 구현할 수 있습니다.
<br>
<br>

- ### DispatchQueue.main.async 와 DispatchQueue.main.sync 의 차이를 설명해보세요.
##### DispatchQueue.main.async는 등록한 작업이 끝나길 기다리지 않고 등록 후 곧바로 다음 코드를 실행합니다. DispatchQueue.main.sync는 등록한 작업이 끝날 때 까지 다음 코드를 실행하지 않습니다. 이때 작업을 등록한 스레드 역시 메인스레드라면 스레드가 sync에 의해 동작을 멈춘 상태에서 메인스레드에 큐에 등록된 작업이 할당됩니다. 메인 스레드는 큐에 등록했던 작업이 끝나길 기다리고, 동시에 메인 스레드에 할당된 작업은 실행되길 기다리기 때문에 데드락 상태에 빠지게 됩니다.
<br>
<br>

- ### 언제 클래스 대신 구조체를 사용하면 좋을까요?
##### 클래스는 구조체와 달리 값 타입이므로 메모리가 공유되지 않고 별도로 유지됩니다. 즉 여러 객체가 공유될 필요가 없고 별도로 동작하길 원할 때 구조체를 사용합니다. 또한 구조체는 메모리의 스택 영역을 사용하면서 각 스레드가 독립적으로 사용되기 때문에 Thread-Safe 하다는 특징이 있습니다.
<br>
<br>

- ### 언제 구조체 대신 클래스를 선택해야할까요?
##### 구조체는 값 타입이기 때문에 같은 인스턴스가 매번 복사되어 사용됩니다. 따라서 만약 어떤 인스턴스의 참조값의 고유성을 유지하고 싶다면 클래스를 사용할 수 있습니다.
<br>
<br>

- ### weak과 unowned 의 차이를 설명하고 예를 들어주세요.
##### weak은 참조하고 있던 인스턴스가 해제되는 것을 염두하여 항상 Optional한 타입을 가집니다. 예를 들어 weak으로 선언한 변수가 참조하고 있던 인스턴스가 메모리에서 해제되면 해당 변수의 값은 nil로 채워집니다. unowned는 참조하던 인스턴스가 만약 메모리에서 해제된 경우, nil을 할당받지 못하고 해제된 메모리 주소값을 계속 들고 있습니다. 예로 unowned로 선언된 변수가 가리키던 인스턴스가 메모리에서 먼저 해제된 경우, 접근하려고 하면 에러를 발생시킵니다.
<br>
<br>

- ### weak만 사용하지 않고 unowned도 사용하는 이유가 무엇을까요?
##### unowned를 사용하면 Optional Binding을 하지 않아도 돼서 코드가 깔끔해진다는 장점이 있기때문입니다.
<br>
<br>

- ### static 변수와 class 변수에 대해 설명해보세요.
##### static 변수와 class 변수 모두 타입 프로퍼티로 클래스, 구조체, 열거형에 모두 사용할 수 있습니다. 타입 프로퍼티는 lazy하게 동작해서 실제로 불리기 전까지는 메모리에 로드되지 않습니다. 타입 프로퍼티는 타입 이름을 통해서만 접근이 가능하고 초기값을 항상 가져야합니다. class로 선언된 타입 프로퍼티는 오버라이딩이 가능하며 static으로 선언된 타입 프로퍼티는 오버라이딩이 불가능합니다.
<br>
<br>

- ### ARC란 무엇인가요?
##### 참조 타입은 하나의 인스턴스가 참조를 통해 여러 곳에서 접근하기 때문에 언제 메모리에서 해제되는지 아는 것이 중요합니다. 적절한 시점에 인스턴스가 해제되지 않으면 한정적인 메모리 자원을 낭비하게 되고, 이는 성능저하로 이어지기 때문입니다. Swift는 이러한 프로그램의 메모리 사용을 관리하기 위해 메모리 관리 기업인 ARC를 사용합니다. ARC는 자동으로 메모리를 관리해줍니다. ARC는 더 이상 필요하지 않은 클래스 인스턴스를 메모리에서 해제합니다.
<br>
<br>

- ### ARC와 GC는 어떤 차이점이 있나요?
##### ARC와 GC의 가장 큰 차이점은 처리 시점에 있습니다. ARC는 Retain과 Release를 컴파일러가 컴파일 타임에 자동으로 삽입해 Reference Count를 조절합니다. 반면에 GC는 가비지 콜렉터를 런타입에 별도로 실행하면서 메모리의 상태를 감시합니다. ARC는 단순히 카운팅을 통해 인스턴스들을 관리하기 때문에 순환참조의 위헙이 있습니다. GC는 Mark-and-Sweep 방식으로 루트노드부터 도달 가능한 인스턴스를 모두 체크합니다. 따라서 순환참조가 발생하더라고 두 인스턴스를 참조하는 인스턴스가 해제되면 루트로부터 순환참조가 발생한 인스턴스들에 도달할 수 있는 경로가 없기 때문에 두 인스턴스를 모두 해제할 수 있습니다.
<br>
<br>

- ### autoclosure attribute에 대해서 설명해보세요.
##### 클로저가 아닌 코드를 함수의 인자로 받을 때 이 코드를 클로저로 만들어주는 키워드입니다. autoclosure를 전달받고 싶으면, 파라미터 타입을 @autoclosure attribute로 marking하면 됩니다. autoclosure는 인자를 가지지 않으며 리턴값이 있어야 합니다. autoclosure로 마킹할 시에 해당 함수를 호출할 때 함수 parameter에 중괄호를 쓰는 것을 생략할 수 있게 해줍니다. autoclosure는 evaluation을 delay 할 수 있게 해줍니다.
<br>
<br>

- ### GCD의 QoS에 대해서 설명해보세요.
##### Qos는 DispatchQueue에 등록하는 작업의 우선순위를 결정할 수 있게 합니다. 우선순위가 높은 작업은 우선순위가 낮은 작업보다 먼저 실행되지만 앱의 리소스를 많이 사용합니다. qos 수준은 userInterative, userInitiated, default, utility, background로 구분됩니다. User Interactive는 애니메이션, 이벤트 처리, UI업데이트 등 사용자와 상호작용하는 작업들을 위한 분류입니다. 사용자 경험을 높이기위해 즉각적으로 반응해야 하므로, 시스템에서 가장 높은 우선순위를 가집니다. User Initiated는 User Interactive와 마찬가지로 반응성과 성능에 중점을 두지만 비교적 요청에 대한 응답이 시간이 소요될 수 있는 작업에 사용합니다. Default는 Qos의 기본값으로 앱을 시작하거나 사용자를 대신하여 활발한 작업을 수행하는 작업 또는 queue에 할당합니다. Utility는 사용자가 적극적으로 확인하거나 추적하지 않는 작업을 위한 분류입니다. 보통 progressbar와 함께 실행되는 다운로드와 같은 작업입니다.Background는 계속 유지해야 하거나 정리해야 하는 작업들을 위한 분류입니다. 가장 낮은 우선 순위를 가지며, 동기화, 백업 등 앱이 백그라운드에서 동작하는 동안 수행해야 하는 작업들에 할당합니다. unspecified는 Qos 정보가 없음을 나타냅니다.

<br>
<br>

- ### init?()과 init()은 어떤 차이가 있나요?
##### init?()은 실패가능한 생성자로 생성자의 코드를 실행하다가 문제가 생겼을 때 nil을 반환하도록 할 수 있습니다.
<br>
<br>

### @frozen에 대해 설명하시오.
##### enum타입에서 case가 추가적으로 생겨나지 않을 것임을 명시하며, 명시할 시 컴파일러는 더욱 효율적으로 작동하게 됩니다. frozen을 붙여줌으로써 default 과정을 없애 불필요한 부분을 없애주고 컴파일 시간을 줄여줍니다.
<br>
<br>

### @unknown에 대해 설명하시오.
##### unknown은 enum타입을 접근하는 switch-case문에서 사용되는 키워드로 추가적인 case가 생겼을 때, 기존에 switch-case문에서 해당 case를 선언하지 않고 @unkknown default로 선언해 놓으면 사용하는 쪽에서 warning 메시지를 받아볼 수 있어 추가된 케이스의 존재를 인지할 수 있게 하는 키워드 입니다. @unknown 키워드를 사룡하지 않고 default만 작성해놓을 경우, 나중에 새로운 case가 추가된다고해도 새로운 case는 default로 빠져버리기 때문에, 추가된 case를 정상적으로 처리하지 못합니다. 따라서 unknown을 사용하여 추가될 case를 인지할 수 있게 해야합니다.
<br>
<br>


- ### Never 반환 타입에 대해 설명해보세요.
##### Never 타입은 비반환 함수에서 반환 값 타입으로 사용됩니다. 즉, 리턴값이 Never인 경우 해당 함수는 비반환 함수가 되고, 비반환 함수 안에서는 오류를 던지거나 중대한 시스템 오류를 보고하는 등의 일을 하고 프로세스를 종료합니다. Never는 빈 Enumeration으로 그냥 하나의 타입입니다. 비반환 함수에 사용되어 반환 값이 없이 프로세스가 종료되는 것을 의미해 주는 타입입니다.
<br>

- ### RunLoop에 대해서 설명해보세요.
##### RunLoop는 스레드 당 하나씩 생성되어 Thread에 작업이 생기면 처리하고, 아닐 때는 대기시키는 역할을 합니다. RunLoop는 Thread를 생성할 때 자동으로 생성되며 메인 스레드를 제외한 스레드에서는 자동으로 실행되지 않고 개발자가 직접 실행시켜주어야 합니다. RunLoop를 실행하면 실행되는 동안 도착한 EventSource를 실행합니다. RunLoop는 한 번만 실행되고 실행이 끝나면 대기상태로 돌아갑니다.
<br>
<br>

- ### GCD에 대해 설명하세요.
##### GCD는 멀티 코어 프로세서 시스템에 대한 응용 프로그램 지원을 최적화하기 위해 Apple에서 개발한 라이브러리이며 DispatchQueue로 작업 실행을 관리합니다. DispatchQueue는 main queue, global queue, private queue로 구분되며 main queue는 한개만 존재하며 Main thread에서 Serial하게 동작합니다. global queue는 Qos를 지정하여 작업의 우선순위를 지정할 수 있으며 Concurrent하게 동작합니다. private queue는 디폴트는 serial로 concurrent로도 설정할 수 있습니다. Qos 설정도 가능하며 global queue에서 동작합니다.

- ### OperationQueue에 대해서 설명해보세요. DispatchQueue와는 어떤 것이 다른가요?
##### 
<br>
<br>

- ### final 키워드를 클래스 앞에 붙이면 어떤 효과가 있을까요?
##### 어떤 클래스의 메소드는 다른 자식 클래스로부터 override될 수 있기 때문에, 이런 override된 메소드는 실제로 어떤 메소드를 실행할지 vtable을 한 번 탐색해서 결정하게 됩니다. 즉, 컴파일 타임이 아닌 런타임에 실제로 실행할 메소드가 결정되는 것 입니다. 이를 dynamic dispatch라고 합니다. 이때 final 키워드를 사용하면 해당 클래스, 프로퍼티, 메소드가 다른 클래스에 의해 상속되고 있지 않다는 것을 컴파일러에게 알려주기 때문에 컴파일 타임에 어떤 메소드를 사용할지 바로 결정할 수 있고, vtable을 거치지 않고 직접적으로 호출되기 때문에 성능상 더 좋은 퍼포먼스를 낼 수 있습니다.
<br>
<br>

- ### 프로퍼티 옵저버에 대해 설명해보세요.
##### 프로퍼티 옵저버는 프로퍼티 값의 변화를 관찰하는 것으로, 기본적으로 저장 프로퍼티에 추가할 수 있습니다. 새 값의 속성이 현재 값과 동일하더라도 속성 값이 설정되면 호출됩니다. willSet옵저버를 구현하면 값이 저장되기 직전에 새로 저장될 값이 파라미터로 전달 됩니다. 이때 파라미터 이름은 지정할 수 있지만 이름을 따로 지정하지 않을 경우 newValue로 사용합니다. didSet 옵저버를 구현하면, 값이 저장된 직후에 이전 프로퍼티 값이 파라미터로 전달됩니다. 이때 파라미터 이름은 지정할 수 있지만 이름을 따로 지정하지 않을 경우 oldValue로 사용합니다. 또 연산 프로퍼티에 프로터피 옵저버를 추가할 수 있는데, 부모 클래스의 연산 프로퍼티를 오버라이딩 할 경우에만 프로퍼티 옵저버를 추가할 수 있습니다.
<br>
<br>

- ### Property Wrapper에 대해 설명해보세요.
##### Property Wrapper는 반복적으로 나타나는 property 구현 패턴에 대한 집합을 컴파일러에 하드코딩하는 대신, 이러한 패턴을 라이브러리로 정의할 수 있는 일반적인 메커니즘을 제공합니다. 어떤 프로퍼티에 행하고싶은 행동을 정의하는 타입을 만들고 타임 앞에 @propertyWrapper를 붙인 후, @와 행동을 정의한 타입의 이름을 행동을 행할 프로퍼티 앞에 붙여주어 사용합니다. Property Wrapper를 사용하면 반복되는 코드를 줄일 수 있습니다.
<br>
<br>

- ### 고차함수 중 flatMap과 compactMap의 차이를 설명해보세요.
##### floatMap은 Map 기능에 반환되는 배열을 flat하게 1차원 배열로 만들어주는 기능이 추가된 메서드 입니다. compactMap은 Map 기능에 반환되는 결과 중 nil이 아닌 결과만 배열에 담아 반환하는 기능이 추가된 메서드입니다.
<br>
<br>

- ### 고차함수(High Order Function)에 대해서 설명해보세요.
##### 고차함수는 다른 함수를 전달인자로 받거나 함수 실행의 결과를 함수로 반환하는 함수입니다. Swift의 함수는 일급객체이기때문에 함수의 전달인자로 전달할 수 있고, 함수의 결과 값으로 반환할 수 있습니다.  Swift의 대표적인 고차함수로는 Map, filter, reduce, compactMap, FlatMap등이 있습니다. map, filter, reduce함수는 Swift 표준 라이브러리의 컨테이너 타입에 구현되어있습니다.
<br>
<br>

- ### 순수함수가 무엇인가요?
##### 순수함수는 외부 상태에 의존적이지 않고, 어떠한 사이드 이펙트도 발생시키지 않는 함수입니다. 이때 함수에서는 외부의 데이터를 직접적으로 사용하지 않고, 파라미터로 받아 사용합니다. input값에 의해 output이 결정되기 때문에 외부의 값들이 변경되더라도 함수 자체에는 외부의 영향을 받지 않기 때문에 사이드 이펙트를 발생시키지 않습니다. 순수함수는 언제 얼마나 많이 호출하든 항상 같은 input에 대해 같은 Output을 반환합니다. 테스트에 용이하고, 재사용성이 올라가며 예측가능성이 높아집니다.
<br>
<br>

- ### 사이드 이펙트는 무엇인가요?
##### 어떤 함수를 호출했을 때 그 함수의 반환값 이외에 호출된 함수 밖에서 프로그램의 상태변화가 발생하는 것을 의미합니다.
<br>
<br>

- ### 순수 함수가 왜 필요하다고 생각하나요?
##### 같은 입력에 대해 항상 같은 동일한 출력을 가지는 순수함수는 테스트가 용이합니다. 외부 상태에 영향을 받지 않기 때문에 해당 함수만 테스트할 수 있기 때문입니다. 사이드 이펙트가 없다는 것은 순수 함수들을 포함하는 객체의 유지보수성이 좋다는 것을 의미합니다. 프로퍼티나 함수들이 다른 함수들에 의존적이지 않기 때문에 확장과 변경이 쉽게 가능합니다.
<br>
<br>

- ### 1급 객체(혹은 1급 시민)에 대해서 설명해보세요. Swift에는 어떤 1급 객체들이 있나요?
##### 1급 객체는 함수의 인자로 전달되거나 반환 값으로 사용할 수 있는 객체를 의미합니다. 또 1급 객체는 변수나 상수에 할당할 수 있는 객체입니다. 스위프트의 기본 타입들이나 함수나 클로저까지 모두 1급 객체에 해당합니다.
<br>
<br>

- ### Optional은 내부적으로 어떻게 구현되어 있나요?
##### Optinal은 associated value를 가지는 enum으로 구현되어있습니다. 값이 존재할 때는 some에 저장된 값을 반환하고, 값이 존재하지 않으면 nil을 반환합니다.
<br>
<br>

- ### Swift에서 참조 타입을 말해보세요.
##### 클래스, 함수, 클로저가 모두 참조 타입입니다.
<br>
<br>

- ### some 키워드에 대해서 설명해보세요.
##### some은 함수 내부에서 반환되는 타입을 외부에서 명확하게 알 수 없도록 합니다. 예를 들어 반환타입부분에 some Collection으로 명시하여 구체적인 타입은 알 수 없지만 Collection을 채택하는 타입이 반환될 것을 보증합니다.
<br>
<br>

- ### KVC에 대해서 설명해보세요.
##### KVC는 Key-Value Coding으로 객체의 값을 직접 사용하지 않고 KeyPath를 이용해 간접적으로 사용하고 수정하는 방법입니다. 
<br>
<br>