## Swift 면접질문 정리

<br>
<br>
<br>

- ### struct와 class와 enum의 차이를 설명하시오.
##### struct는 상속이 불가능하며 stack영역에 저장됩니다. 또한 속도가 빠르며 멀티 쓰레드 환경에서 안전하고 값 타입입니다. class는 단일 상속이 가능하며, heap 영역에 저장되고 상대적으로 느립니다. 클래스는 참조타입이며, enum은 상속이 불가능하고 값 타입입니다.
<br>
<br>

- ### 메모리 구조와 각 역할에 대해 설명하시오.
##### 메모리는 코드, 데이터, 힙, 스택으로 이루어져 있습니다. 코드영역에는 우리가 작성한 소스코드가 binary 형태로 저장되며, Read-Only로 저장됩니다. 데이터 영역에는 전역변수, static 변수가 저장되며, 프로그램 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리가 해제됩니다. 실행 도중 값이 변경될 수 있으므로 Read-Write로 저장됩니다. 힙 영역에는 참조 타입의 값이 저장되며 Swift는 ARC를 통해 힙에 할당된 메모리가 더 이상 참조되지 않으면 자동으로 메모리를 해제해줍니다. 스택에는 함수의 호출과 관계되는 지역변수와 매개변수가 저장됩니다. 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸합니다. 스택은 LIFO 방식으로 작동하며 CPU에 의해 관리되고 최적화 돼서 속도가 매우 빠릅니다.
<br>
<br>


- ### Copy On Write는 어떤 방식으로 동작하는지 설명하시오.
##### 프로그래밍에서 복사 동작을 할 때, 실제 원본이나 복사본이 수정되기 전까지는 복사를 하지 않고 원본 리소스를 공유하다가 원본이나 복사본에서 수정이 일어날 경우, 그때 복사를 진행하는 방식으로 동작합니다.
<br>
<br>

- ### Convinience init에 대해 설명하시오.
##### Designated init의 파라미터 중 일부를 기본값으로 설정해서, 이 convenience init안에서 Designated init을 호출하여 초기화를 진행할 수 있습니다. convenience init을 사용하기 위해서는 designated init이 반드시 먼저 선언되어야 합니다.
<br>
<br>

- ### Any에 대해 설명하시오.
##### Any는 모든 타입의 인스턴스를 나타낼 수 있는 범용 타입입니다. value 타입, Reference타입이건 상관없이 저장이 가능합니다.
<br>
<br>

- ### AnyObject에 대해 설명하시오.
##### AnyObject는 모든 클래스 타입의 인스턴스를 나타낼 수 있는 프로토콜입니다. 따라서 클래스 타입이 아닌 구조체, 열거형, 클로저는 AnyObject에 해당하지 않습니다.
<br>
<br>

- ### Optional 이란 무엇인지 설명하시오.
##### 변수의 값이 있을 수도있고 nil일 수 있다는 것을 표현하는 것 입니다. Optional 변수의 선언은 ?키워드를 사용하며 디폴트 값은 nil입니다.
<br>
<br>

- ### Struct 가 무엇이고 어떻게 사용하는지 설명하시오.
##### 구조체란 인스턴스 프로퍼티를 저장하거나 메소드를 제공하고 이를 캡슐화할 수 있는 타입(named type)입니다. struct키워드로 정의하며 대문자 카멜케이스를 사용합니다. 구조체 정의 후 기본적으로 생성되는 멤버와이즈 이니셜라이저를 사용하여 초기화할 수 있으며 프로퍼티 값에 접근하고 싶다면 마침표를 사용하면 됩니다.
<br>
<br>

- ### Subscripts에 대해 설명하시오.
##### 콜렉션, 리스트, 시퀀스 등 집합의 특정 member elements에 접근할 수 있는 문법입니다. 서브스크립트는 subscript키워드로 작성하며 하나 이상의 파라미터와 반환 값을 지정하여 정의합니다. getter와 setter 모두 구현가능하며, get-only는 가능하지만, set-only는 불가능합니다.
<br>
<br>

- ### String은 왜 subscript로 접근이 안되는지 설명하시오.
##### String은 1개 이상의 Unicode Scalar로 이루어져있습니다. 그리고 유니코드 시스템에선 글자 하나가 반드시 1바이트라는 보장이 없습니다. 하나의 이모티콘은 여러개의 unicodeScalars로 이루어져 있는 것을 확인할 수 있습니다. 또 String은 하나의 값에 다양한 뷰를 제공하기 때문에, 단순히 Int타입으로 글자들을 참조하기에는 어떠한 뷰를 기준으로 인덱싱을 지원해야하는 지에 대해 애매한 부분이 존재합니다. 이 때문에 String은 별도로 설계된 String.Index라는 구조체를 제공하여 인덱싱을 지원합니다.
<br>
<br>

- ### 함수와 메서드의 차이를 설명하시오.
##### func 키워드로 생성하는 재사용 가능한 코드 블록을 함수라고 하며 func으로 선언한 함수가 클래스, 구조체, 열거형 속에 포함되어 있다면 메서드라고 표현합니다.
<br>
<br>

- ### instance 메서드와 class 메서드의 차이점을 설명하시오.
##### 먼저 intstance 메서드는 인스턴스 메서드이기 때문에 인스턴스와 연관된 메서드로 인스턴스를 생성해야만 호출이 가능합니다. 하지만 class 메서드는 타입 메서드이기 때문에 인스턴스를 생성하지 않아도 타입으로 접근할 수 있습니다.
<br>
<br>

- ### class 메서드와 static 메서드의 차이점을 설명하시오.
##### class 메서드와 static 모두 Type 메서드이지만 메서드 오버라이딩에 있어서 차이가 있습니다. static 메서드는 Subclass에서 해당 타입의 메서드를 오버라이딩 하는 것을 금지합니다. class는 static과 반대로 Subclass에서 해당 타입 메서드를 오버라이딩 하는 것을 허용합니다.
<br>
<br>

- ### Delegate 패턴을 활용하는 경우를 예를 들어 설명하시오.
##### ViewController를 보면, TableView의 특정 셀에 있는 여러 개의 버튼 중 특정 버튼을 눌렀을 경우에 해야할 일을 ViewController로 넘겨주기 위해 Delegate 패턴을 사용합니다. TableViewCell이 선택되었을 경우 호출하는 기능은 TableView Delegate에서 기본적으로 처리하고있지만, 셀 내부의 특정 버튼에 대한 이벤트는 처리할 수 없습니다. 이와 같은 경우엔 Custom Delegate를 만들어 구현이 가능합니다.
<br>
<br>

- ### Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.
##### 싱글톤 패턴은 객체를 하나 생성해서 공용으로 사용하고 싶을 때 사용하는 방법입니다. 즉. 인스턴스가 하나만 존재하는 것을 보증하고 싶을 경우에 사용하게 되는데, 주로 환경설정, 네트워크 객체, 로그인 정보 등을 넣어두고 필요할 때마다 여러 객체에서 접근 가능하도록 합니다.
<br>
<br>

- ### KVO 동작 방식에 대해 설명하시오.
##### KVO는 객체의 어떤 값이 변경되었을 경우 특정 메시지를 보내 처리할 수 있도록 하는 것입니다. 즉, 변수에 코드를 붙여 변수가 변경될 때마다 특정 코드가 실행되도록 하는 방법을 의미합니다. property observers(willset, didSet)고 아주 유사한데 KVO는 타입 정의 밖에서 observe를 추가한다는 점에서 다릅니다. KVO를 구현하려면 먼저 감지하려는 객체에 옵저버를 등록하고 객체의 변화가 일어났을 때 옵저버의 메시지를 받아 처리하면 됩니다. Objective-C 런타임에 의존하기 때문에 NSObject를 채택해야하고, 관찰할 프로퍼티에는 @objc 와 dynamic 키워드를 붙여야 합니다.
<br>
<br>

- ### Delegates와 Notification 방식의 차이점에 대해 설명하시오.
##### 먼저 두 방식 모두 객체간의 소통을 위해 만들어진 것인데, 먼저 delegate는 protocol을 정의하고 이 이벤트를 대신 처리할 객체가 채택하여 사용하게 되기때문에 주로 1:1로 이벤트를 전달할 때 많이 사용됩니다. notification 방식은 이벤트를 1:N으로 전달할 때 용이합니다. NotificationCenter라는 싱글톤객체를 기반으로 이벤트 발생여부를 옵저버를 등록한 객체에게 전달하는 방식으로 구성됩니다. 따라서 다수의 객체에게 손쉽게 이벤트 전달이 가능합니다.
<br>
<br>

- ### 프로토콜이란 무엇인지 설명하시오.
##### protocol은 특정 작업또는 기능을 구현하기 위한 메소드, 프로퍼티 그리고 기타 다른 요구사항들의 청사진입니다. 즉 protocol은 정의만 제시하고 세부적인 구현은 해당 protocol을 채택한 Type에서 구현합니다.
<br>
<br>

- ### Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.
##### Hashable은 정수 hash값을 제공하는 타입으로 정의된 프로토콜입니다. 해시값은 인스턴스를 식별하는 값으로 유일성을 가지고 있어야 합니다. 해시 값이 유일한 값인지를 비교해야하기 때문에 Equatable 프로토콜을 상속 받아 값을 비교할 수 있도록 하고있습니다.
<br>
<br>

- ### mutating 키워드에 대해 설명하시오.
##### Swift에서 구조체와 열거형과 같은 값 타입의 속성은 기본적으로 인스턴스 메서드 내에서 수정할 수 없습니다. 값 타입의 속성을 수정하려면 인스턴스 내에서 mutating키워드를 사용해야합니다. func 키워드 앞에 mutating 키워드를 작성하면 값 타입 프로퍼티를 수정할 수 있습니다.
<br>
<br>

- ### 탈출 클로저에 대하여 설명하시오.
##### Swift에서는 함수의 파라미터로 전달된 클로저는 기본적으로 함수 내부에서만 사용이 가능합니다. 즉 파라미터로 전달받은 클로저는 내부에서 직접 호출만 가능하고, 외부 변수/상수에 저장하는 것이 불가능한 형태입니다. 이때 클로저 앞에 @escaping 키워드를 사용하면 해당 클로저를 외부 변수/상수에 저장이 가능하며, 해당 함수가 끝나서 리턴된 이후에도 클로저 실행이 가능합니다.
<br>
<br>

- ### Extension에 대해 설명하시오.
##### Extension이란 기존 클래스, 구조체, 열거형 타입에 새로운 Property, Method, Initializer 등을 추가하는 것입니다. 저장 프로퍼티는 추가할 수 없으며, 연산 프로퍼티만 추가 가능합니다. 메서드는 인스턴스 메서드, 타입 메서드 모두 추가 가능합니다. Class에서는 Designated Initializer와 deinitializer는 추가할 수 없으며, Convenience initializer만 추가할 수 있습니다. Struct에서 extension으로 생성자를 추가할 시에는 Memberwise Initializer를 보존하며 새로운 Initializer를 추가할 수 있습니다. 또한 Where을 사용하여 특정 조건을 만족시킬 때만 기능을 확장시킬 수 있습니다.
<br>
<br>

- ### Extension 내부에서 함수를 override할 수 있는지 설명하시오.
##### 기본적으로 불가능하며 메소드가 Objective-C와 호환되는 경우에만 메소드를 Override할 수 있습니다. 즉, @objc 키워드를 func 앞에 작성해주면 Extension에서 해당 함수를 override할 수 있습니다. 이러한 동작이 가능한 이유는 컴파일러가 Objective-C와의 호환성을 위해 Extension에서 Override를 허용하기 때문입니다.
<br>
<br>

- ### 접근 제어자의 종류엔 어떤게 있는지 설명하시오.
##### 접근제어자로는 open, public, internal, fileprivate, private이 있습니다. 먼저 private은 가장 한정적인 범위로 기능을 정의하고 구현한 범위 내에서만 사용이 가능합니다. Fileprivate는 Fileprivate으로 지정된 요소가 구현된 소스파일 내부에서만 사용이 가능합니다. Internal은 직접 표기하지 않아도 기본적으로 적용되는 접근 수준으로 해당 모듈 전체에서 사용 가능합니다. public과 Open 모두 선언한 모듈이 아닌 다른 모듈에서도 사용가능합니다. 
<br>
<br>

- ### open과 public 키워드의 차이를 설명해보세요.
##### Open은 다른 모듈에서 오버라이드와 서브클래싱이 가능하지만 Public 접근자로 선언된 것은 다른 모듈에서는 오버라이드와 서브클래싱이 불가능합니다.
<br>
<br>

- ### fileprivate을 설명하고 언제 사용하면 좋을지 이야기해보세요.
##### fileprivate은 같은 소스파일 내에서의 접근만 허용합니다. 따라서 같은 파일 내부에서만 사용될 때 filprivate으로 제한하면 좋습니다.
<br>
<br>

- ### fileprivate과 private의 차이를 설명해보세요.
##### fileprivate은 같은 파일 내부에 있다면 접근을 허용했지만, private은 같은 파일에 있어도 private으로 선언한 대상의 구현부 내부, 그리고 같은 파일에 있는 동일한 선언의 Extension에서만 접근이 가능합니다.
<br>
<br>


- ### defer란 무엇인지 설명하시오.
##### defer문이 속한 스코프 밖으로 프로그램 흐름이 transfering되기 전에 실행되는 코드 구역입니다. 다중 defer문이 존재한다면 역순으로 실행됩니다. 하지만 defer문을 만나기 전에 종료된다면 스택에 저장될 수 없으므로 스코프 종료 후에도 defer 문이 실행되지 않습니다.
<br>
<br>

- ### defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.
##### defer는 순차적으로 스택에 저장하기 때문에 LIFO로 호출됩니다. 즉 선언된 역순으로 호출되며 선언된 코드 블럭을 빠져나가기 직전에 실행됩니다. defer가 호출되지 않는 경우는 throw를 이용하여 오류를 던질 경우입니다. defer 구문에 도달하기 전에 함수가 종료되어 버리면 스택에 저장 될 수 없기 때문에 defer가 호출되지 않습니다. guard문을 사용하여 중간에 함수를 종료하는 경우에도 동일한 이유로 호출되지 않습니다. 또한 리턴값이 Never인 경우에도 호출되지 않습니다.
<br>
<br>

- ### Generic에 대해 설명하시오.
##### 제네릭이란 타입에 의존하지 않는 범용 코드를 작성할 때 사용합니다. 제네릭을 사용하면 중복을 피하고, 코드를 유연하게 작성할 수 있습니다. 제네릭 함수를 통해 함수를 호출할 때 Type Parameter의 타입을 결정하여 타입에 상관없이 함수를 사용할 수 있습니다. 또한 구조체, 클래스, 열거형에도 제네릭을 결합할 수 있으며, 제네릭 타입이라고 합니다.
<br>
<br>

- ### Result타입에 대해 설명하시오.
##### Result타입은 success와 failure 두 가지 case가 있는 enum입니다. 그중 Failure은 Error Protocol을 준수해야합니다. 기존의 throwing function은 정확히 어떤 에러 형식을 던지는지 파악하기 어려운 반면 Result Type을 활용하면 작업의 결과를 명확히 구분 가능합니다. 네트워크와 같이 실패할 가능성이 있는 작업의 성공여부와 결과를 쉽게 표현할 수 있습니다.
<br>
<br>

- ### Typealias에 대해 설명하시오.
##### Typealias는 기존에 선언되어있는 유형에 새로운 유형의 별칭을 사용함으로써 코드를 더 쉽게 이해할 수 있게 하는 문법입니다. Swift에서는 typealias를 대부분의 유형에 사용할 수 있으며, 크게 내장 유형, 사용자 정의 유형, 복합 유형이 있습니다.
<br>
<br>

- ### Codable에 대하여 설명하시오.
##### Codable이라는 Typealias는 Decodable과 Encodable 프로토콜을 준수하는 타입입니다.
<br>
<br>


- ### enum / function / closure 각각 value type 인가 reference type 인가?
##### enum은 값 타입이며 function과 closure는 참조타입입니다.
<br>
<br>

- ### Array, Dictionary, Set 등의 컬렉션 타입은 value type 인가 reference type 인가?
##### Struct로 구현되어있으므로 값 타입입니다.
<br>
<br>

- ### Set에 대하여 설명하시오.
##### set은 정렬되지 않은 컬렉션입니다. 배열과 달리 중복 요소를 허용하지 않으며, 해시를 통해 값을 저장하기 때문에 배열에 비해 검색 속도가 빠르고, 저장되는 자료형은 Hashable 프로토콜을 준수하고 있어야 합니다. 또한 Set도 배열, 딕셔너리와 같은 Collection Type이기 때문에, 구조체로 Stack에 저장됩니다.
<br>
<br>

- ### Swift의 upcasting과 downcasting의 차이에 대해서 설명해보세요.
##### upcasting은 상속 관계가 있는 클래스들끼리만 가능합니다. as를 사용하여 업 캐스팅 할 수 있으며 컴파일 타임에 타입 캐스팅하여 항상 성공합니다. downcasting은 슈퍼 클래스 인스턴스를 서브 클래스 타입으로 참조합니다. 다운 캐스팅은 실패할 수 있기 때문에 as?, as! 연산자를 사용합니다.
<br>
<br>

- ### as? 와 as! 차이를 설명해보세요.
##### as?는 실패할 경우 nil을 리턴합니다. as!는 실패할 경우 에러가 발생합니다.
<br>
<br>

- ### == 연산자와 === 연산자는 어떻게 다른가요? 
##### == 연산자는 값을 비교하는데 사용되고, === 연산자는 참조 값을 비교하는데 사용됩니다.
<br>
<br>

- ### Enum에서 raw value와 associated value에 대해 설명해보세요
##### raw value 원시값은 모든 케이스가 동일한 형식을 사용해야하고, 케이스당 값을 하나밖에 저장할 수 없는 한계점이 있는데, 연관 값은 튜플을 사용하여 하나의 케이스에 서로 다른 연관값들을 저장할 수 있습니다. named tuple을 사용하여 이름을 붙일 수도 있으며, 다양한 타입을 가진 여러개의 값들을 가지게 할 수 있습니다.
<br>
<br>

- ### inout은 언제 사용하면 좋을까요?
##### swift에서 파라미터는 기본적으로 상수입니다. 이러한 파라미터를 수정하고 싶을 때 파라미터의 형식 앞에 inout키워드를 작성한 후 함수를 호출할 때 인자값으로 넘어가는 변수명 왼쪽에 & 기호를 붙여 사용합니다. 이러한 역할을 수행하는 inout 키워드는 매개변수로 넘겨진 변수의 값을 함수 내에서 변경시키고 함수가 반환된 후에도 이 변환된 값을 원본 변수에 적용시키고 싶을 때 사용합니다.
<br>
<br>

- ### 메서드 안에서 언제 self를 사용해야할까요?
##### 파라미터의 이름이 인스턴스 프로퍼티 이름과 겹칠 경우, 인스턴스의 프로퍼티임을 명시하기 위해서 self를 사용할 수 있습니다.
<br>
<br>

- ### Class와 Struct의 공통점과 차이점을 설명해보세요.
##### Class와 Struct 모두 값을 저장할 프로퍼티를 선언할 수 있으며, 메서드를 선언할 수 있습니다. 내부 값에 .을 사용하여 접근할 수 있고, 생성자를 사용해 초기 상태를 설정할 수 있습니다. Extension을 사용하여 기능을 확장할 수 있으며, protocol을 채택하여 기능을 설정할 수 있습니다. 하지만 Class는 참조타입이며, ARC로 메모리를 관리합니다. 또한 상속이 가능하며 타입 캐스팅을 통해 런타임에서 클래스 인스턴스 타입을 확인할 수 있습니다. 반면에 Struct는 값 타입이며, 상속이 불가능합니다.
<br>
<br>

- ### 강한 참조는 무엇이고 왜 필요한가요?
##### 강한 참조는 참조 타입 인스턴스를 변수에 할당하는 것을 의미합니다. 스위프트의 ARC는 강한 참조에 참조 카운트를 증가시킵니다. 따라서 강한 참조가 있어야만 스위프트에서 참조 타입의 인스턴스를 메모리에 유지할 수 있습니다.
<br>
<br>

- ### strong, weak, unowned reference는 각각 언제 사용할까요?
##### 메모리에서 인스턴스가 해제되는 것을 막기 위해 Strong reference를 사용할 수 있습니다. strong reference는 참조 카운트를 1 증가시키기 때문에 메모리에서 해제되지 않습니다. weak reference는 참조 카운트를 증가시키지 않습니다. weak reference는 항상 var로 선언되는 옵셔널 타입이 되어야 합니다. weak으로 참조하고 있던 인스턴스가 해제될 수 있기 때문입니다. 순환 참조의 가능성이 있는 상황에서 weak을 통해 방지할 수 있습니다. unowned reference는 weak과 동일하게 참조 카운트를 증가시키지 않습니다. 그리고 unowned로 선언된 변수는 nil을 가질 수 없습니다. unowned로 참조하고 있던 인스턴스가 해제되면 unowned는 nil이 아니라 더 이상 참조할 수 없는 주소를 계속 참조하게 되고 unowned 변수를 참조하려고 하면 런타임 에러가 발생합니다. 따라서 unowned는 해당 변수가 참조하는 인스턴스보다 먼저 해제되는 것이 확실한 상황에서만 사용해야합니다.
<br>
<br>

- ### Array, Set, Dictionary의 차이점이 뭘까요?
##### Array는 리스트 컬렉션으로 인덱스를 통해 요소에 접근할 수 있습니다. Set은 Hashable 프로토콜을 채택하는 값을 저장해 중복되지 않은 데이터를 관리합니다. 순서가 보장되지 않으며, 교집합, 차집합 등 집합 연산을 메서드로 제공합니다. Dictionary는 Key-Value 형태로 데이터를 관리하는 콜렉션입니다. 딕셔너리의 Key로 사용될 타입은 Hashable 프로토콜을 채택하고 중복된 키를 허용하지 않으며 순서를 보장하지 않습니다.
<br>
<br>

- ### required 키워드에 대해서 설명해보세요.
##### required 키워드를 사용하여 이니셜라이저를 지정할 수 있습니다. 이 필수 이니셜라이저는 모든 자식 클래스에서 반드시 구현해야 하는 이니셜라이저로, required 키워드를 붙여 사용 가능하고 자식 클래스에서 구현할 때에도 required 키워드를 붙여야 합니다. required는 오버라이드를 기본으로 포함하고 있습니다.
<br>
<br>

- ### Self와 self의 차이가 뭘까요?
##### self는 현재 인스턴스를 가리킵니다. Self는 프로토콜에서 사용되면 프로토콜을 채택하는 타입을 의미하고, 클래스나 구조체, 열거형에서 사용되면 실제 선언에 사용된 타입을 의미합니다.
<br>
<br>

- ### Array보다 Set을 사용하는게 더 좋을 때는 언제일까요?
##### 순서가 중요하지 않고 데이터를 중복없이 고유하게 관리할 때 Set을 사용하는 것이 더 좋습니다. 특히 Set은 삭제, 삽입, 조회를 모두 O(1)에 할 수 있기 때문에 순서가 중요하지 않으면서 삭제와 삽입이 빈번할 때도 Set이 더 좋을 수 있습니다.
<br>
<br>

- ### Trailing Closure에 대해서 설명해보세요.
##### 함수의 파라미터로 클로저를 넣을 때가 있습니다. 그 중 함수의 파라미터 중 마지막 파라미터가 클로저일 경우에는 trailing closure를 사용하여 함수를 호출하는 부분의 바깥에 클로져를 적어
<br>
<br>

- ### deinit은 언제 사용할까요?
##### deinit은 인스턴스가 메모리에서 해제되기 직전에 호출됩니다. 인스턴스를 해제하기 전에 선행되어야 하는 작업이 있다면 deinit에 구현할 수 있습니다.
<br>
<br>

- ### DispatchQueue.main.async 와 DispatchQueue.main.sync 의 차이를 설명해보세요.
##### DispatchQueue.main.async는 작업을 등록할 때 async하게 등록하기 때문에 등록한 작업이 끝나길 기다리지 않고 등록 후 곧바로 다음 코드를 실행합니다. DispatchQueue.main.sync는 작업을 등록할 때 sync하게 등록하기 때문에 등록한 작업이 끝날 때 까지 다음 코드를 실행하지 않습니다. 이때 작업을 등록한 스레드 역시 메인스레드라면 스레드가 sync에 의해 동작을 멈춘 상태에서 메인스레드에 큐에 등록된 작업이 할당됩니다. 메인 스레드는 큐에 등록했던 작업이 끝나길 기다리고, 동시에 메인 스레드에 할당된 작업은 실행되길 기다리기 때문에 데드락 상태에 빠지게 됩니다.
<br>
<br>

- ### 언제 클래스 대신 구조체를 사용하면 좋을까요?
##### 
<br>
<br>

- ### 언제 구조체 대신 클래스를 선택해야할까요?
##### 
<br>
<br>

- ### weak과 unowned 의 차이를 설명하고 예를 들어주세요.
##### weak은 참조하고 있던 인스턴스가 해제되는 것을 염두하여 항상 Optional한 타입을 가집니다. 예를 들어 weak으로 선언한 변수가 참조하고 있던 인스턴스가 메모리에서 해제되면 해당 변수의 값은 nil로 채워집니다. unowned는 참조하던 인스턴스가 만약 메모리에서 해제된 경우, nil을 할당받지 못하고 해제된 메모리 주소값을 계속 들고 있습니다. 예로 unowned로 선언된 변수가 가리키던 인스턴스가 메모리에서 먼저 해제된 경우, 접근하려고 하면 에러를 발생시킵니다.
- ### weak만 사용하지 않고 unowned도 사용하는 이유가 무엇을까요?
https://babbab2.tistory.com/83
- ### staic 변수와 class 변수에 대해 설명해보세요.
##### 
<br>
<br>

- ### ARC와 GC는 어떤 차이점이 있나요?
##### 
<br>
<br>

- ### autoclosure attribute에 대해서 설명해보세요.
##### 
<br>
<br>

- ### GCD의 QoS에 대해서 설명해보세요.
##### 
<br>
<br>

- ### init?()과 init()은 어떤 차이가 있나요?
##### 
<br>
<br>

- ### Never 반환 타입에 대해 설명해보세요.
##### 
<br>
<br>

- ### RunLoop에 대해서 설명해보세요.
##### 
<br>
<br>

- ### autoreleasepool에 대해서 설명해보세요.
##### 
<br>
<br>

- ### OperationQueue에 대해서 설명해보세요. DispatchQueue와는 어떤 것이 다른가요?
##### 
<br>
<br>

- ### final 키워드를 클래스 앞에 붙이면 어떤 효과가 있을까요?
##### 어떤 클래스의 메소드는 다른 자식 클래스로부터 override될 수 있기 때문에, 이런 override된 메소드는 실제로 어떤 메소드를 실행할지 vtable을 한 번 탐색해서 결정하게 됩니다. 즉, 컴파일 타임이 아닌 런타임에 실제로 실행할 메소드가 결정되는 것 입니다. 이를 dynamic dispatch라고 합니다. 이때 final 키워드를 사용하면 해당 클래스, 프로퍼티, 메소드가 다른 클래스에 의해 상속되고 있지 않다는 것을 컴파일러에게 알려주기 때문에 컴파일 타임에 어떤 메소드를 사용할지 바로 결정할 수 있고, vtable을 거치지 않고 직접적으로 호출되기 때문에 성능상 더 좋은 퍼포먼스를 낼 수 있습니다.
<br>
<br>

- ### 프로퍼티 옵저버에 대해 설명해보세요.
##### 프로퍼티 옵저버는 프로퍼티 값의 변화를 관찰하는 것으로, 저장 프로퍼티에 추가할 수 있습니다. 새 값의 속성이 현재 값과 동일하더라도 속성 값이 설정되면 호출됩니다. willSet옵저버를 구현하면 값이 저장되기 직전에 새로 저장될 값이 파라미터로 전달 됩니다. 이때 파라미터 이름은 지정할 수 있지만 이름을 따로 지정하지 않을 경우 newValue로 사용합니다. didSet 옵저버를 구현하면, 값이 저장된 직후에 이전 프로퍼티 값이 파라미터로 전달됩니다. 이때 파라미터 이름은 지정할 수 있지만 이름을 따로 지정하지 않을 경우 oldValue로 사용합니다.
<br>
<br>

- ### Property Wrapper에 대해 설명해보세요.
##### 
<br>
<br>

- ### 고차함수 중 flatMap과 compactMap의 차이를 설명해보세요.
##### 
<br>
<br>

- ### 고차함수(High Order Function)에 대해서 설명해보세요.
##### 
<br>
<br>

- ### 함수형 프로그래밍은 무엇인가요? Swift는 함수형 프로그래밍 언어인가요?
##### 
<br>
<br>

- ### 순수함수가 무엇인가요?
##### 
<br>
<br>

- ### 그럼 사이드 이펙트는 무엇인가요?
##### 
<br>
<br>

- ### 순수 함수가 왜 필요하다고 생각하나요?
##### 
<br>
<br>

- ### 1급 객체(혹은 1급 시민)에 대해서 설명해보세요. Swift에는 어떤 1급 객체들이 있나요?
##### 
<br>
<br>

- ### Optional은 내부적으로 어떻게 구현되어 있나요?
##### 
<br>
<br>

- ### Swift에서 참조 타입을 말해보세요.
##### 
<br>
<br>

- ### some 키워드에 대해서 설명해보세요.
##### 
<br>
<br>

- ### KVC에 대해서 설명해보세요.
##### 
<br>
<br>