## iOS 면접질문 정리

<br>
<br>
<br>

- ### struct와 class와 enum의 차이를 설명하시오.
##### struct는 상속이 불가능하며 stack영역에 저장됩니다. 또한 속도가 빠르며 멀티 쓰레드 환경에서 안전하고 값 타입입니다. class는 단일 상속이 가능하며, heap 영역에 저장되고 상대적으로 느립니다. 클래스는 참조타입이며, enum은 상속이 불가능하고 값 타입입니다.
<br>
<br>

- ### 메모리 구조와 각 역할에 대해 설명하시오.
##### 메모리 즉 RAM은 코드, 데이터, 힙, 스택으로 이루어져 있습니다. 코드영역에는 우리가 작성한 소스코드가 binary 형태로 저장되며, Read-Only로 저장됩니다. 데이터 영역에는 전역변수, static 변수가 저장되며, 프로그램 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리가 해제됩니다. 실행 도중 값이 변경될 수 있으므로 Read-Write로 저장됩니다. 힙 영역에는 참조 타입의 값이 저장되며 Swift는 ARC를 통해 힙에 할당된 메모리가 더 이상 참조되지 않으면 자동으로 메모리를 해제해줍니다. 스택에는 함수의 호출과 관계되는 지역변수와 매개변수가 저장됩니다. 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸합니다. 스택은 LIFO 방식으로 작동하며 CPU에 의해 관리되고 최적화 돼서 속도가 매우 빠릅니다.
<br>
<br>

- ### class의 성능을 향상 시킬수 있는 방법들을 나열해보시오.
#####
<br>
<br>

- ### Copy On Write는 어떤 방식으로 동작하는지 설명하시오.
##### 프로그래밍에서 복사 동작을 할 때, 실제 원본이나 복사본이 수정되기 전까지는 복사를 하지 않고 원본 리소스를 공유하다가 원본이나 복사본에서 수정이 일어날 경우, 그때 복사를 진행하는 방식으로 동작합니다.
<br>
<br>

- ### Convinience init에 대해 설명하시오.
##### Designated init의 파라미터 중 일부를 기본값으로 설정해서, 이 convenience init안에서 Designated init을 호출하여 초기화를 진행할 수 있습니다. convenience init을 사용하기 위해서는 designated init이 반드시 먼저 선언되어야 합니다.
<br>
<br>

- ### Any에 대해 설명하시오.
##### Any는 함수타입을 포함하여 모든 타입의 인스턴스를 나타낼 수 있는 범용 타입입니다. value 타입, Reference타입이건 상관없이 저장이 가능합니다.
<br>
<br>

- ### AnyObject에 대해 설명하시오.
##### AnyObject는 모든 클래스 타입의 인스턴스를 나타낼 수 있는 프로토콜입니다. AnyObject로 선언 시, 클래스 타입만 저장할 수 있습니다. 따라서 클래스 타입이 아닌 구조체, 열거형, 클로저는 AnyObject에 해당하지 않습니다.
<br>
<br>

- ### Optional 이란 무엇인지 설명하시오.
##### 변수의 값이 있을 수도있고 nil일 수 있다는 것을 표현하는 것 입니다. Optional 변수의 선언은 ?키워드를 사용하며 디폴트 값은 nil입니다.
<br>
<br>

- ### Struct 가 무엇이고 어떻게 사용하는지 설명하시오.
##### 구조체란 인스턴스 프로퍼티를 저장하거나 메소드를 제공하고 이를 캡슐화할 수 있는 스위프트가 제공하는 타입(named type)입니다. struct키워드로 정의하며 대문자 카멜케이스를 사용합니다. 구조체 정의 후 기본적으로 생성되는 멤버와이즈 이니셜라이저를 사용하여 초기화할 수 있으며 프로퍼티 값에 접근하고 싶다면 마침표를 사용하면 됩니다.
<br>
<br>

- ### Subscripts에 대해 설명하시오.
##### 콜렉션, 리스트, 시퀀스 등 집합의 특정 member elements에 접근할 수 있는 문법입니다. 서브스크립트는 subscript키워드로 작성하며 하나 이상의 파라미터와 반환 값을 지정하여 정의합니다. getter와 setter 모두 구현가능하며, get-only는 가능하지만, set-only는 불가능합니다.
<br>
<br>

- ### String은 왜 subscript로 접근이 안되는지 설명하시오.
##### String은 1개 이상의 Unicode Scalar로 이루어져있습니다. 그리고 유니코드 시스템에선 글자 하나가 반드시 1바이트라는 보장이 없습니다. 하나의 이모티콘은 여러개의 unicodeScalars로 이루어져 있는 것을 확인할 수 있습니다. 또 String은 하나의 값에 다양한 뷰를 제공하기 때문에, 단순히 Int타입으로 글자들을 참조하기에는 어떠한 뷰를 기준으로 인덱싱을 지원해야하는 지에 대해 애매한 부분이 존재합니다. 이 때문에 String은 별도로 설계된 String.Index라는 구조체를 별도로 제공하여 인덱싱을 지원합니다.
<br>
<br>

- ### 함수와 메서드의 차이를 설명하시오.
##### func 키워드로 생성하는 모든것을 함수라고 하며 func으로 선언한 함수가 클래스, 구조체, 열거형 속에 포함되어 있다면 메서드라고 표현합니다.
<br>
<br>

- ### class 메서드와 static 메서드의 차이점을 설명하시오.
##### class 메서드와 static 모두 Type 메서드이지만 메서드 오버라이딩에 있어서 차이가 있습니다. static 메서드는 Subclass에서 해당 타입의 메서드를 오버라이딩 하는 것을 금지합니다. class는 static과 반대로 Subclass에서 해당 타입 메서드를 오버라이딩 하는 것을 허용합니다.
<br>
<br>

- ### Delegate 패턴을 활용하는 경우를 예를 들어 설명하시오.
##### ViewController를 보면, TableView의 특정 셀에 있는 여러 개의 버튼 중 특정 버튼을 눌렀을 경우에 해야할 일을 ViewController로 넘겨주기 위해 Delegate 패턴을 사용합니다. TableViewCell이 선택되었을 경우 호출하는 기능은 TableView Delegate에서 기본적으로 처리하고있지만, 셀 내부의 특정 버튼에 대한 이벤트는 처리할 수 없습니다. 이와 같은 경우엔 Custom Delegate를 만들어 구현이 가능합니다.
<br>
<br>

- ### Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.
##### 싱글톤 패턴은 객체를 하나 생성해서 공용으로 사용하고 싶을 때 사용하는 방법입니다. 즉. 인스턴스가 하나만 존재하는 것을 보증하고 싶을 경우에 사용하게 되는데, 주로 환경설정, 네트워크 객체, 로그인 정보 등을 객체에 넣어두고 필요할 때마다 여러 객체에서 접근 가능하도록 합니다.
<br>
<br>

- ### KVO 동작 방식에 대해 설명하시오.
##### KVO는 모델 객체의 어떤 값이 변경되었을 경우 이를 UI에 반영하기 위해서 컨트롤러는 모델 객체에 Observing을 도입하여 델리게이트에 특정 메시지를 보내 처리할 수 있도록 하는 것입니다. 즉, 변수에 코드를 붙여 변수가 변경될 때마다 코드가 실행되도록 하는 방법을 의미합니다. property observers(willset, didSet)고 아주 유사한데 KVO는 타입 정의 밖에서 observe를 추가한다는 점에서 다릅니다. KVO를 구현하려면 먼저 감지하려는 객체에 옵저버를 등록하고 객체의 변화가 일어났을 때 옵저버의 메시지를 받아 처리하면 됩니다.
<br>
<br>

- ### Delegates와 Notification 방식의 차이점에 대해 설명하시오.
##### 먼저 두 방식 모두 객체간의 소통을 위해 만들어진 것인데, delegate 방식은 주로 1:1로 이벤트를 전달할 때 많이 사용됩니다. 주로 protocol을 정의하고 이 이벤트를 대신 처리할 객체가 채택하여 사용하게 됩니다. notification 방식은 이벤트를 1:N으로 전달할 때 용이합니다. NotificationCenter라는 싱글톤객체를 기반으로 이벤트 발생여부를 옵저버를 등록한 객체에게 전달하는 방식으로 구성됩니다. 따라서 다수의 객체에게 손쉽게 이벤트 전달이 가능합니다.
<br>
<br>

- ### 프로토콜이란 무엇인지 설명하시오.
##### protocol은 특정 작업 혹은 기능들을 구현하기 위한 메소드, 프로퍼티 그리고 기타 다른 요구사항들의 청사진입니다. 즉 protocol은 정의만 제시하고 세부적인 구현은 해당 protocol을 채택한 Type에서 구현합니다. protocol 키워드를 사용하여 UpperCamelCase로 정의합니다.
<br>
<br>

- ### Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.
##### Hashable은 정수 hash값을 제공하는 타입으로 정의된 프로토콜입니다.해시값은 각각 타입의 인스턴스를 식별하는 값으로 유일성을 가지고 있어야 합니다. 해시 값이 유일한 값인지를 비교해야하기 때문에 Equatable 프로토콜을 상속 받아 값을 비교할 수 있도록 하고있습니다.
<br>
<br>

- ### mutating 키워드에 대해 설명하시오.
##### Swift에서 구조체와 열거형과 같은 값 타입의 속성은 기본적으로 인스턴스 메서드 내에서 수정할 수 없습니다. 값 타입의 속성을 수정하려면 인스턴스 내에서 mutating키워드를 사용해야합니다. func 키워드 앞에 mutating 키워드를 작성하면 값 타입 프로퍼티를 수정할 수 있습니다.
<br>
<br>

- ### 탈출 클로저에 대하여 설명하시오.
##### Swift에서는 함수의 파라미터로 전달된 클로저는 기본적으로 함수 내부 스코프 안에서만 사용이 가능합니다. 즉 파라미터로 전달받은 클로저는 내부에서 직접 호출만 가능하고, 외부 변수/상수에 저장하는 것이 불가능한 형태입니다. 이때 클로저 앞에 @escaping 키워드를 사용하면 해당 클로저를 외부 변수/상수에 저장이 가능하며, 해당 함수가 끝나서 리턴된 이후에도 클로저 실행이 가능합니다.
<br>
<br>

- ### Extension에 대해 설명하시오.
##### Extension이란 기존 클래스, 구조체, 열거형 타입에 새로운 Property, Method, Initializer 등을 추가하는 것입니다. 저장 프로퍼티는 추가할 수 없으며, 연산 프로퍼티만 추가 가능합니다. 메서드는 인스턴스 메서드, 타입 메서드 모두 추가 가능합니다. 또한 기존 타입에 새로운 이니셜라이저를 추가할 수 있는데 Class에서는 Designated Initializer와 deinitializer는 추가할 수 없으며, Convenience initializer만 추가할 수 있습니다. Struct에서 extension으로 생성자를 추가할 시에는 Memberwise Initializer를 보존하며 새로운 생성자를 추가할 수 있습니다. 또한 Where을 사용하여 특정 조건을 만족시킬 때만 기능을 확장시키거나 프로토콜을 채택하도록 설정할 수 있습니다.
<br>
<br>

- ### Extension 내부에서 함수를 override할 수 있는지 설명하시오.
##### 메소드가 Objective-C와 호환되는 경우에만 메소드를 Override할 수 있습니다. 즉, @objc 키워드를 func 앞에 작성해주면 Extension에서 해당 함수를 override할 수 있습니다. 이러한 동작이 가능한 이유는 컴파일러가 Objective-C와의 호환성을 위해 Extension에서 Override를 허용하기 때문입니다.
<br>
<br>

- ### 접근 제어자의 종류엔 어떤게 있는지 설명하시오.
##### 접근제어는 접근 수준 키워드를 통해 구현이 가능한데 키워드의 종류로는 open, public, internal, fileprivate, private이 있습니다. 먼저 private은 가장 한정적인 범위로 기능을 정의하고 구현한 범위 내에서만 사용이 가능합니다. Fileprivate는 Fileprivate으로 지정된 요소가 구현된 소스파일 내부에서만 사용이 가능합니다. Internal은 직접 표기하지 않아도 기본적으로 적용되는 접근 수준으로 해당 모듈 전체에서 사용 가능합니다. public과 Open 모두 선언한 모듈이 아닌 다른 모듈에서 사용가능합니다. 두 접근자의 차이점은 Open은 다른 모듈에서 오버라이드와 서브클래싱이 가능하지만 Public 접근자로 선언된 것은 다른 모듈에서는 오버라이드와 서브클래싱이 불가능합니다.
<br>
<br>

- ### defer란 무엇인지 설명하시오.
##### defer문이 속한 스코프 밖으로 프로그램 흐름이 transfering되기 전에 실행되는 코드 구역입니다. 다중 defer문이 존재한다면 역순으로 실행됩니다. 하지만 defer문을 만나기 전에 종료된다면 스택에 저장될 수 없으므로 스코프 종료 후에도 defer 문이 실행되지 않습니다.
<br>
<br>

- ### defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.
##### defer는 순차적으로 스택에 저장하기 때문에 LIFO로 호출됩니다. 즉 선언된 역순으로 호출되며 선언된 코드 블럭을 빠져나가기 직전에 실행됩니다. defer가 호출되지 않는 경우는 throw를 이용하여 오류를 던질 경우입니다. defer 구문에 도달하기 전에 함수가 종료되어 버리면 스택에 저장 될 수 없기 때문에 defer가 호출되지 않습니다. guard문을 사용하여 중간에 함수를 종료하는 경우에도 동일한 이유로 호출되지 않습니다. 또한 리턴값이 Never인 경우에도 호출되지 않습니다.
<br>
<br>

- ### property wrapper에 대해서 설명하시오.
##### Property wrapper는 프로퍼티가 저장되는 방식을 관리하는 코드와 프로퍼티를 정의하는 코드 사이에 분리 계층을 추가합니다. 예를 들어 개발을 하다보면 Thread-safe한 프로퍼티 또는 값을 DB에 저장하는 프로퍼티가 여러 개 필요한 경우가 있습니다. 이럴 때 Thread-safe처리나 DB 커넥션 처리 등을 각각의 프로퍼티에 모두 작성해주어야 했습니다. Property wrapper를 사용하게 되면 이런 중복되는 코드들을 한 번만 작성하면 됩니다. 그 후 필요한 프로퍼티들에서 이 wrapper를 가져다 적용함으로써 하나의 코드를 재사용할 수 있게 됩니다. 
<br>
<br>

- ### Generic에 대해 설명하시오.
##### 제네릭이란 타입에 의존하지 않는 범용 코드를 작성할 때 사용합니다. 제네릭을 사용하면 중복을 피하고, 코드를 유연하게 작성할 수 있습니다. 제네릭 함수를 통해 함수를 호출할 때 Type Parameter의 타입을 결정하여 타입에 상관없이 함수를 사용할 수 있습니다. 또한 구조체, 클래스, 열거형에도 제네릭을 결합할 수 있으며, 제네릭 타입이라고 합니다.
<br>
<br>

- ### Result타입에 대해 설명하시오.
##### Result타입은 Swift 5에 새롭게 추가된 에러 처리 방식으로 success와 failure 두 가지 case가 있는 enum입니다. 그중 Failure은 Error Protocol을 준수해야합니다. 기존의 throwing function은 정확히 어떤 에러 형식을 던지는지 파악하기 어려운 반면 Result Type을 활용하면 작업의 결과를 명확히 구분이 가능합니다.
<br>
<br>

- ###  Typealias에 대해 설명하시오.
##### Typealias는 기존에 선언되어있는 유형에 새로운 유형의 별칭을 사용함으로써 코드를 더 쉽게 읽고, 이해할 수 있도록 만드는 문법입니다. Swift에서는 typealias를 대부분의 유형에 사용할 수 있으며, 크게 내장 유형, 사용자 정의 유형, 복합 유형이 있습니다.
<br>
<br>

- ### Codable에 대하여 설명하시오.
##### Codable이라는 Typealias는 Decodable과 Encodable 프로토콜을 준수하는 타입이다.
<br>
<br>


- ### enum / function / closure 각각 value type 인가 reference type 인가?
##### enum은 값 타입이며 function과 closure는 참조타입입니다.
<br>
<br>

- ### Array, Dictionary, Set 등의 컬렉션 타입은 value type 인가 reference type 인가?
##### Struct로 구현되어있으므로 값 타입입니다.
<br>
<br>